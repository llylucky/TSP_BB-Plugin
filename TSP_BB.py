# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TSP_BB
                                 A QGIS plugin
 Get the best route
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-08
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Lingyu LI
        email                : 2587326506@qq.cm
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QVariant
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog, QSizePolicy, QGridLayout

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .TSP_BB_dialog import TSP_BBDialog
import os.path
from qgis.core import *
import qgis.utils
from qgis.gui import QgsMapLayerComboBox, QgsMessageBar

from queue import PriorityQueue
import numpy as np
import random
import copy

class TSP_BB:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TSP_BB_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = TSP_BBDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&TSP_BB')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'TSP_BB')
        self.toolbar.setObjectName(u'TSP_BB')
        self.dlg.pushButton.clicked.connect(self.select_output_file)
        self.dlg.pushButton_2.clicked.connect(self.random_point_layer)
        self.dlg.pushButton_3.clicked.connect(self.deal_algorithm)
        self.dlg.pushButton_4.clicked.connect(self.close_dialog)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TSP_BB', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/TSP_BB/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'tsp_bb'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&TSP_BB'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def select_output_file(self):
        filename = QFileDialog.getSaveFileName(self.dlg, "Select output file", "", 'ESRI Shapefile(*.shp *.SHP)')
        self.dlg.lineEdit.setText(filename[0])

    def random_point_layer(self):
        id = 1
        random_pointlayer = QgsVectorLayer('point?crs=epsg:4326', 'Random points', 'memory')
        pr = random_pointlayer.dataProvider()
        pr.addAttributes([QgsField('ID', QVariant.Int)])
        random_pointlayer.updateFields()
        for i in range(0, int(self.dlg.spinBox.value())):
            seg = QgsFeature(random_pointlayer.fields())
            seg.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(random.uniform(-180, 180), random.uniform(-90, 90))))
            seg.setAttribute('ID', id)
            id = id + 1
            pr.addFeatures([seg])
        random_pointlayer.updateExtents()
        QgsProject.instance().addMapLayers([random_pointlayer])

    def deal_algorithm(self):
        class Node(object):
            def __init__(self, level=None, path=None, bound=None, maxsize=0):
                self.level = level
                self.path = path
                self.bound = bound

            def __cmp__(self, other):
                return cmp(self.bound, other.bound)

            def __str__(self):
                return str(tuple([self.level, self.path, self.bound]))

            def __lt__(self, other):
                return self.bound < other.bound

        def travel(adj_mat):
            optimal_tour = []
            n = len(adj_mat)
            u = Node()
            PQ = PriorityQueue()
            optimal_length = 0
            v = Node(level=0, path=[0])
            min_length = float('inf')  # infinity
            v.bound = bound(adj_mat, v)
            PQ.put(v)
            while not PQ.empty():
                v = PQ.get()
                if v.bound < min_length:
                    u.level = v.level + 1
                    for i in list(filter(lambda x: x not in v.path, range(1, n))):
                        u.path = v.path[:]
                        u.path.append(i)
                        if u.level == n - 2:
                            l = set(range(1, n)) - set(u.path)
                            u.path.append(list(l)[0])
                            # putting the first vertex at last
                            u.path.append(0)

                            _len = length(adj_mat, u)
                            if _len < min_length:
                                min_length = _len
                                optimal_length = _len
                                optimal_tour = u.path[:]
                                self.dlg.progressBar.setValue(50 - n)

                        else:
                            u.bound = bound(adj_mat, u)
                            if u.bound < min_length:
                                PQ.put(u)

                        # make a new node at each iteration! python it is!!
                        u = Node(level=u.level)
            return optimal_tour

        def length(adj_mat, node):
            tour = node.path
            # returns the sum of two consecutive elements of tour in adj[i][j]
            return sum([adj_mat[tour[i]][tour[i + 1]] for i in range(len(tour) - 1)])

        def bound(adj_mat, node):
            path = node.path
            _bound = 0

            n = len(adj_mat)
            determined, last = path[:-1], path[-1]
            # remain is index based
            remain = list(filter(lambda x: x not in path, range(n)))

            # for the edges that are certain
            for i in range(len(path) - 1):
                _bound += adj_mat[path[i]][path[i + 1]]

            # for the last item
            _bound += min([adj_mat[last][i] for i in remain])

            p = [path[0]] + remain
            # for the undetermined nodes
            for r in remain:
                _bound += min([adj_mat[r][i] for i in list(filter(lambda x: x != r, p))])
            return _bound

        def NNH(start):
            x = list(range(n))
            route = [start]
            for i in range(n - 2):
                x.remove(route[-1])
                com = [mat[route[-1]][x[j]] for j in range(len(x))]
                route.append(x[com.index(min(com))])
            x.remove(route[-1])
            route.append(x[0])
            route.append(route[0])
            s = sum([mat[route[i]][route[i + 1]] for i in range(n)])
            return s, route

        filename = self.dlg.lineEdit.text()
        selectedlayer = self.dlg.mMapLayerComboBox.currentLayer()
        if not selectedlayer:
            self.iface.messageBar().pushMessage('Wrong or missing parameter value', 'Input layer', level=1, duration=3)
        else:
            coordinates = [feature.geometry().asPoint() for feature in selectedlayer.getFeatures()]
            QgsDistanceArea().setSourceCrs(selectedlayer.crs(), QgsProject().transformContext())
            QgsDistanceArea().setEllipsoid('WGS84')
            n = len(coordinates)
            mat = np.eye(n, n) * 0
            for i1 in range(0, n, 1):
                for i2 in range(i1, n, 1):
                    mat[i1][i2] = mat[i2][i1] = QgsDistanceArea().convertLengthMeasurement(QgsDistanceArea().measureLine(coordinates[i1], coordinates[i2]), QgsUnitTypes().DistanceMeters)
            if self.dlg.checkBox.isChecked():
                bestlayer_NNH = QgsVectorLayer("linestring?crs=" + selectedlayer.sourceCrs().toWkt(),
                                               filename[(filename.rfind("/") + 1):filename.rfind(".")] + "_NNH",
                                               "memory")
                pr = bestlayer_NNH.dataProvider()
                pr.addAttributes([QgsField('ID', QVariant.Int), QgsField("Length", QVariant.Double)])
                bestlayer_NNH.updateFields()
                s = [NNH(i)[0] for i in range(n)]
                route = [NNH(i)[1] for i in range(n)]
                route_best = route[s.index(min(s))]
                id = 1
                for i in range(0, n):
                    seg = QgsFeature(bestlayer_NNH.fields())
                    seg.setGeometry(
                        QgsGeometry.fromPolylineXY([coordinates[route_best[i]], coordinates[route_best[i + 1]]]))
                    seg.setAttributes([id, float(str(mat[route_best[i]][route_best[i + 1]]))])
                    id = id + 1
                    pr.addFeatures([seg])
                bestlayer_NNH.updateExtents()
                symbol2 = QgsLineSymbol.createSimple({'line_style': 'dash', 'width': '1', 'color': 'blue'})
                bestlayer_NNH.renderer().setSymbol(symbol2)
                QgsProject.instance().addMapLayers([bestlayer_NNH])
            tour = travel(mat)
            self.dlg.progressBar.setValue(90)
            bestroute_layer = QgsVectorLayer("linestring?crs=" + selectedlayer.sourceCrs().toWkt(),
                                             filename[(filename.rfind("/") + 1):filename.rfind(".")], "memory")
            pr = bestroute_layer.dataProvider()
            pr.addAttributes([QgsField('ID', QVariant.Int), QgsField("Length", QVariant.Double)])
            bestroute_layer.updateFields()
            id=1
            for i in range(0, n):
                seg = QgsFeature(bestroute_layer.fields())
                seg.setGeometry(QgsGeometry.fromPolylineXY([coordinates[tour[i]], coordinates[tour[i + 1]]]))
                seg.setAttributes([id, float(str(mat[tour[i]][tour[i + 1]]))])
                id = id + 1
                pr.addFeatures([seg])
            bestroute_layer.updateExtents()
            symbol1 = QgsLineSymbol.createSimple({'line_style': 'simple', 'width': '1', 'color': 'red'})
            bestroute_layer.renderer().setSymbol(symbol1)
            QgsProject.instance().addMapLayers([bestroute_layer])
            QgsVectorFileWriter.writeAsVectorFormat(bestroute_layer, filename, 'utf-8', selectedlayer.crs(),
                                                    'ESRI Shapefile')
            self.dlg.progressBar.setValue(100)

    def close_dialog(self):
        self.dlg.close()

    def run(self):
        """Run method that performs all the real work"""
        self.dlg.lineEdit.clear()
        self.dlg.spinBox.setValue(0)
        self.dlg.progressBar.setValue(0)
        self.dlg.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.PointLayer)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pass
